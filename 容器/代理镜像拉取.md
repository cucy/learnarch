您遇到的问题非常关键，并且揭示了处理 **Docker 默认 Registry 镜像**时的常见陷阱。

`处理文件: /root/busybox.yml - 忽略: busybox:1.36 (不是公共 Registry 镜像或已是本地镜像)`

这个错误信息说明了：

1.  脚本成功找到了 `/root/busybox.yml` 文件。
2.  它也找到了 `image: busybox:1.36` 这一行。
3.  但是，它判断 `busybox:1.36` **不属于**您在 `PUBLIC_REGISTRIES` 中列出的任何公共 Registry（例如 `docker.io/`），所以没有修改它。

**根本原因：**
当镜像名称没有前缀（如 `busybox:1.36`, `nginx:latest`）时，Docker 默认从 `docker.io` 拉取。但是，YAML 文件中通常会省略 `docker.io/` 这个默认前缀。您的脚本只检查 `image` 字段是否以 `docker.io/` 开头，所以对于没有前缀的镜像就会忽略。

**解决方案：**
我们需要修改脚本的逻辑：
*   如果一个 `image` 字段**没有**任何 Registry 前缀（即不包含 `/`，除了标签前的 `/`），那么就认为它是 `docker.io` 的镜像。
*   同时，修改脚本，使其在扫描文件时跳过隐藏目录（例如 `.k8s_yaml_backup_` 目录），提高效率和避免不必要的输出。

---

### **修正后的 Python 脚本：**

请将您的 `k8s_image_modifier.py` 脚本替换为以下内容。我已在代码中添加了详细注释，说明了修改的地方。

```python
#!/usr/bin/env python3

import os
import sys
import shutil
from datetime import datetime
from ruamel.yaml import YAML
from ruamel.yaml.comments import CommentedMap, CommentedSeq

# =========================================================================
# K8s YAML 镜像地址修改与恢复脚本 (Python 实现)
#
# 该脚本用于批量修改 K8s YAML 文件中的镜像地址，指向 Mac 上的本地 Docker Registry，
# 并提供恢复功能。
# =========================================================================

# --- 用户可配置参数 ---
# 您的 Mac 电脑在局域网内的 IP 地址，例如 192.168.1.16
YOUR_MAC_LAN_IP = "192.168.1.16"  # <--- 务必修改为您的 Mac 实际 IP！

# Mac 上本地 Registry 的端口，通常为 5000
LOCAL_REGISTRY_PORT = "5000"

# K8s YAML 文件所在的根目录 (脚本会递归查找 .yaml 或 .yml 文件)
# 请务必根据您的实际情况设置。如果所有YAML都在/root下或其子目录，则设为"/root"。
K8S_YAML_ROOT_DIR = "/root"  # <--- 根据您的输出，这里设置为 /root。请确认！

# 需要修改的公共 Registry 列表 (脚本会检查 image 是否以这些开头)
# 请注意，这些前缀必须以 '/' 结尾，例如 "docker.io/"
PUBLIC_REGISTRIES = [
    "docker.io/",
    "k8s.gcr.io/",
    "gcr.io/",
    "registry.k8s.io/",
    "quay.io/", # 示例，如果使用 quay.io 的镜像
    # 添加其他您使用的公共 Registry 前缀
]

# --- 内部变量 (通常无需修改) ---
LOCAL_REGISTRY_PREFIX = f"{YOUR_MAC_LAN_IP}:{LOCAL_REGISTRY_PORT}/"
IMAGE_MODIFIED_LIST_FILE = "mac_docker_push_commands.sh"

# --- 函数定义 ---

def check_root():
    """检查是否为 root 用户"""
    if os.geteuid() != 0:
        print("此脚本需要 root 权限运行。请使用 sudo。", file=sys.stderr)
        sys.exit(1)

def find_yaml_files(root_dir):
    """递归查找指定目录下的所有 .yaml 和 .yml 文件，跳过隐藏目录"""
    yaml_files = []
    for dirpath, dirs, filenames in os.walk(root_dir):
        # 排除隐藏目录，以及以 .k8s_yaml_backup_ 开头的备份目录
        dirs[:] = [d for d in dirs if not d.startswith('.') and not d.startswith('.k8s_yaml_backup_')]
        
        for filename in filenames:
            if filename.endswith((".yaml", ".yml")):
                yaml_files.append(os.path.join(dirpath, filename))
    return yaml_files

def get_yaml_parser():
    """获取 YAML 解析器实例"""
    yaml = YAML()
    yaml.preserve_quotes = True  # 保留字符串的引用样式
    yaml.width = 1000 # 防止长行被折叠
    return yaml

def find_and_modify_images(data, mac_registry_prefix, public_registries, images_to_push_set):
    """递归查找并修改 YAML 数据中的 image 字段"""
    modified = False
    
    if isinstance(data, CommentedMap):
        if 'image' in data:
            original_image = str(data['image'])
            
            # 1. 检查是否已包含本地 Registry 前缀，如果是则跳过
            if original_image.startswith(mac_registry_prefix):
                print(f"  - 忽略: {original_image} (已是本地 Registry 镜像)")
                # 不需要修改，但仍然遍历其子结构
                for key, value in data.items():
                    if find_and_modify_images(value, mac_registry_prefix, public_registries, images_to_push_set):
                        modified = True
                return modified

            # 标记是否已经匹配并修改了
            found_and_modified = False
            full_original_image = original_image # 默认情况下，完整的原始镜像就是它自己

            # 2. 检查是否以已知公共 Registry 前缀开头
            for registry_prefix in public_registries:
                if original_image.startswith(registry_prefix):
                    local_image_path = original_image[len(registry_prefix):]
                    new_image = mac_registry_prefix + local_image_path
                    data['image'] = new_image
                    full_original_image = original_image # 明确完整路径
                    images_to_push_set.add(full_original_image) # 添加原始完整镜像路径
                    modified = True
                    found_and_modified = True
                    print(f"  - 修改: {original_image} -> {new_image}")
                    break # 找到匹配的公共 Registry 就跳出内层循环
            
            # 3. 如果没有明确的 Registry 前缀，则假定它是 docker.io 的镜像
            # 这里的判断条件是：如果 image 字符串中没有 '/' (除了可能的标签前的 '/')
            # 例如 "busybox:latest" vs "myregistry.com/myimage:latest"
            if not found_and_modified:
                # 检查 image name 部分是否包含斜杠 (不包含标签)
                # 例如 "repo/image:tag" -> "repo/image"
                # "image:tag" -> "image"
                image_name_part = original_image.split(':', 1)[0]
                if '/' not in image_name_part:
                    # 假设这是 docker.io 的隐式镜像
                    full_original_image = "docker.io/" + original_image
                    new_image = mac_registry_prefix + original_image
                    data['image'] = new_image
                    images_to_push_set.add(full_original_image) # 务必添加完整的原始路径用于 pull
                    modified = True
                    found_and_modified = True
                    print(f"  - 修改 (隐式 docker.io): {original_image} -> {new_image} (原始完整路径: {full_original_image})")
                else:
                    # 它包含斜杠，但没有匹配任何已知的公共 Registry。
                    # 这可能是一个私有 Registry，或者一个未列出的公共 Registry，我们不处理。
                    print(f"  - 忽略: {original_image} (不是公共 Registry 镜像或已是本地镜像)")

        # 递归遍历子项
        for key, value in data.items():
            if find_and_modify_images(value, mac_registry_prefix, public_registries, images_to_push_set):
                modified = True
    elif isinstance(data, CommentedSeq):
        for item in data:
            if find_and_modify_images(item, mac_registry_prefix, public_registries, images_to_push_set):
                modified = True
    return modified

def enable_proxy():
    """启用代理：修改 YAML 并生成 Mac 推送命令"""
    print("--- 正在启用 K8s YAML 镜像代理配置 ---")
    print(f"将修改 {K8S_YAML_ROOT_DIR} 下的 YAML 文件。")
    print(f"Mac Registry 地址: {LOCAL_REGISTRY_PREFIX}")

    # 1. 备份 YAML 文件
    backup_timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
    backup_dir = os.path.join(K8S_YAML_ROOT_DIR, f".k8s_yaml_backup_{backup_timestamp}")
    print(f"备份 K8s YAML 文件到 {backup_dir}...")
    
    try:
        # 复制整个目录及其内容
        # shutil.copytree 要求目标目录不存在，如果存在需要先删除或用 dirs_exist_ok=True (Python 3.8+)
        # 如果K8S_YAML_ROOT_DIR下有非YAML文件或子目录不想备份，这里需要更复杂的逻辑
        # 最稳妥是复制所有文件，然后移动到backup_dir
        
        # 创建一个临时目录用于备份
        temp_backup_dir = os.path.join(K8S_YAML_ROOT_DIR, f".temp_k8s_yaml_backup_{backup_timestamp}")
        os.makedirs(temp_backup_dir, exist_ok=True) # 确保临时目录存在

        # 遍历K8S_YAML_ROOT_DIR下的所有文件和子目录，复制到临时备份目录
        for item in os.listdir(K8S_YAML_ROOT_DIR):
            item_path = os.path.join(K8S_YAML_ROOT_DIR, item)
            # 排除当前的temp_backup_dir，避免无限循环
            if item_path == temp_backup_dir or item_path == backup_dir or item.startswith(".k8s_yaml_backup_"):
                continue

            if os.path.isdir(item_path):
                shutil.copytree(item_path, os.path.join(temp_backup_dir, item), dirs_exist_ok=True)
            else:
                shutil.copy2(item_path, os.path.join(temp_backup_dir, item))
        
        # 将临时备份目录重命名为最终备份目录
        shutil.move(temp_backup_dir, backup_dir)
        print("备份完成。")
    except Exception as e:
        print(f"错误：备份文件失败！{e}", file=sys.stderr)
        return False

    # 2. 生成 Mac Docker 推送命令文件
    print(f"生成 Mac Docker 推送命令文件：{IMAGE_MODIFIED_LIST_FILE}")
    with open(IMAGE_MODIFIED_LIST_FILE, 'w') as f:
        f.write("#!/bin/bash\n")
        f.write("# ======================================================================\n")
        f.write("# 以下是在您的 Mac 电脑上需要执行的 Docker 命令，用于将镜像推送到本地 Registry。\n")
        f.write(f"# 请确保您的 Mac 已运行 Docker Desktop 和本地 Registry 容器 (端口 {LOCAL_REGISTRY_PORT})。\n")
        f.write("# ======================================================================\n\n")
    os.chmod(IMAGE_MODIFIED_LIST_FILE, 0o755)

    # 3. 遍历并修改 YAML 文件
    yaml_files = find_yaml_files(K8S_YAML_ROOT_DIR)
    modified_count = 0
    images_to_push_set = set() # 使用集合去重

    yaml_parser = get_yaml_parser()

    for yaml_file_path in yaml_files:
        print(f"处理文件: {yaml_file_path}")
        try:
            with open(yaml_file_path, 'r') as f:
                data = yaml_parser.load(f)
            
            # 使用 find_and_modify_images 函数处理 YAML 数据
            if find_and_modify_images(data, LOCAL_REGISTRY_PREFIX, PUBLIC_REGISTRIES, images_to_push_set):
                modified_count += 1
                with open(yaml_file_path, 'w') as f:
                    yaml_parser.dump(data, f)
                print(f"文件 {yaml_file_path} 已修改。")
            else:
                print("  - 无可修改的 image 字段或已是本地镜像。")
        except Exception as e:
            print(f"错误：处理文件 {yaml_file_path} 失败！{e}", file=sys.stderr)
            continue
    
    # 4. 写入 Mac Docker 推送命令 (去重)
    with open(IMAGE_MODIFIED_LIST_FILE, 'a') as f:
        f.write("\n# --- Unique Docker commands to push to local registry ---\n")
        for original_full_image in sorted(list(images_to_push_set)):
            # 根据 full_original_image 生成新的本地 tagged image 名称
            new_tagged_image = original_full_image
            
            # 移除公共 Registry 前缀
            found_prefix = False
            for registry_prefix in PUBLIC_REGISTRIES:
                if original_full_image.startswith(registry_prefix):
                    new_tagged_image = LOCAL_REGISTRY_PREFIX + original_full_image[len(registry_prefix):]
                    found_prefix = True
                    break
            
            # 如果是隐式 docker.io 镜像，其 full_original_image 应该以 "docker.io/" 开头
            # 例如 original_full_image = "docker.io/busybox:1.36"
            if not found_prefix and original_full_image.startswith("docker.io/"):
                 new_tagged_image = LOCAL_REGISTRY_PREFIX + original_full_image[len("docker.io/"):]
            
            f.write(f"docker pull {original_full_image}\n")
            f.write(f"docker tag {original_full_image} {new_tagged_image}\n")
            f.write(f"docker push {new_tagged_image}\n\n")

    print("--- 代理配置已成功启用！ ---")
    print(f"共修改了 {modified_count} 个 YAML 文件中的镜像地址。")
    print("\n下一步：请将以下文件复制到您的 Mac 电脑上，并在 Mac 终端中运行它：")
    print(f"  {IMAGE_MODIFIED_LIST_FILE}")
    print(f"例如：scp {IMAGE_MODIFIED_LIST_FILE} user@{YOUR_MAC_LAN_IP}:~/")
    print(f"然后在 Mac 上执行：bash ~/{IMAGE_MODIFIED_LIST_FILE}")
    print("\n完成后，您的 Ubuntu K8s 节点即可通过本地 Registry 拉取镜像。")
    return True

def disable_proxy():
    """禁用代理：恢复 YAML"""
    print("--- 正在禁用 K8s YAML 镜像代理配置 ---")

    # 查找最近的备份目录
    all_backups = [d for d in os.listdir(K8S_YAML_ROOT_DIR) if d.startswith(".k8s_yaml_backup_")]
    if not all_backups:
        print(f"未找到 K8s YAML 备份目录在 {K8S_YAML_ROOT_DIR}，无法恢复。请手动检查。", file=sys.stderr)
        return False
    
    # 获取最新备份目录 (基于名称的日期时间戳)
    all_backups.sort(reverse=True)
    latest_backup = os.path.join(K8S_YAML_ROOT_DIR, all_backups[0])

    print(f"从备份目录 {latest_backup} 恢复 K8s YAML 文件...")
    
    try:
        # 清理当前目录下的所有 .yaml/.yml 文件及子目录，然后从备份恢复
        # 确保只清理被脚本影响的文件，不清理无关文件
        # 首先删除目标路径下的所有.yaml/.yml文件和脚本可能创建的备份子目录
        for root, dirs, files in os.walk(K8S_YAML_ROOT_DIR, topdown=False):
            # 排除当前正在处理的备份目录
            if root.startswith(latest_backup):
                continue
            
            for f in files:
                if f.endswith((".yaml", ".yml")):
                    os.remove(os.path.join(root, f))
            for d in dirs:
                dir_path = os.path.join(root, d)
                if dir_path.startswith(latest_backup) or d.startswith(".k8s_yaml_backup_"): # Avoid deleting backup folder itself
                    continue
                shutil.rmtree(dir_path)

        # 复制备份内容到原目录
        shutil.copytree(latest_backup, K8S_YAML_ROOT_DIR, dirs_exist_ok=True)
        print("恢复完成。")
        
        print(f"清理备份目录 {latest_backup}...")
        shutil.rmtree(latest_backup)
        
        # 清理生成的 Mac Docker 推送命令文件
        if os.path.exists(IMAGE_MODIFIED_LIST_FILE):
            os.remove(IMAGE_MODIFIED_LIST_FILE)
            print(f"已删除生成的 Mac Docker 推送命令文件：{IMAGE_MODIFIED_LIST_FILE}")
        
    except Exception as e:
        print(f"错误：恢复或清理失败！{e}", file=sys.stderr)
        return False

    print("--- K8s YAML 镜像代理配置已成功禁用！ ---")
    print("您的 K8s YAML 文件已恢复到修改前的状态。")
    return True


def display_usage():
    """显示脚本用法"""
    print(f"用法: sudo {sys.argv[0]} [enable|disable]")
    print("  enable  - 启用 K8s YAML 镜像代理配置，修改 YAML，并生成 Mac 推送指令。")
    print("  disable - 禁用 K8s YAML 镜像代理配置，从备份恢复 YAML。")
    print("\n当前配置的 Mac IP: {YOUR_MAC_LAN_IP}")
    print(f"当前配置的本地 Registry 端口: {LOCAL_REGISTRY_PORT}")
    print(f"当前 K8s YAML 根目录: {K8S_YAML_ROOT_DIR}")
    print("请务必修改脚本顶部的这三个变量以适应您的环境。")

if __name__ == "__main__":
    check_root()
    if len(sys.argv) != 2:
        display_usage()
        sys.exit(1)

    command = sys.argv[1]

    if command == "enable":
        print(f"您确定要启用 K8s YAML 镜像代理配置吗？这会修改 {K8S_YAML_ROOT_DIR} 下的 YAML 文件。(y/N)")
        confirm = input().strip().lower()
        if confirm == 'y':
            enable_proxy()
        else:
            print("操作已取消。")
    elif command == "disable":
        print(f"您确定要禁用 K8s YAML 镜像代理配置吗？这会恢复 {K8S_YAML_ROOT_DIR} 下的 YAML 文件。(y/N)")
        confirm = input().strip().lower()
        if confirm == 'y':
            disable_proxy()
        else:
            print("操作已取消。")
    else:
        display_usage()
        sys.exit(1)
```

---

### **关键修正点：**

1.  **`find_and_modify_images` 函数逻辑优化：**
    *   **处理隐式 `docker.io` 镜像：** 现在，如果镜像名称（不包含标签部分）中没有 `/`，脚本会假定它是 `docker.io` 的镜像（例如 `busybox:1.36` 实际上是 `docker.io/busybox:1.36`）。它会将其完整路径加入 `images_to_push_set`，并将其在 YAML 中修改为 `YOUR_MAC_LAN_IP:5000/busybox:1.36`。
    *   **避免重复处理已修改的镜像：** 如果 `image` 字段已经以 `LOCAL_REGISTRY_PREFIX` 开头，则跳过修改。

2.  **`find_yaml_files` 函数优化：**
    *   在 `os.walk` 中，修改 `dirs` 列表，明确跳过以 `.` 开头的隐藏目录，以及脚本自身创建的备份目录（`.k8s_yaml_backup_`）。

3.  **`K8S_YAML_ROOT_DIR` 设置：**
    在脚本中，我将 `K8S_YAML_ROOT_DIR` 默认值改为了 `/root`。请**务必根据您实际的 YAML 文件存放位置进行准确设置**。如果您的 K8s YAML 文件分散在 `/root` 下的多个子目录中（例如 `/root/k8s-install/` 和 `/root/other-yamls/`），那么 `/root` 可能是正确的根目录。如果它们都集中在 `/root/k8s-install` 里面，那么 `/root/k8s-install` 仍然是更精确的选择。

4.  **备份和恢复逻辑微调：**
    *   备份时，不再直接 `shutil.copytree` 整个 `K8S_YAML_ROOT_DIR` 到 `backup_dir`，而是先复制到临时目录再移动，避免一些 `shutil.copytree` 的限制。
    *   恢复逻辑也进行了微调，以确保在复杂的文件结构下也能正确覆盖并清理。

---

### **再次使用步骤：**

1.  **确认您的 Mac 上的 ClashX 和 Docker Registry 运行正常**，且 Mac IP 和端口正确。
2.  **确保您已安装 `ruamel.yaml` 库：**
    ```bash
    sudo apt update
    sudo apt install -y python3-pip
    pip3 install ruamel.yaml
    ```
3.  **用上面修正后的代码替换您的 `k8s_image_modifier.py` 文件内容。**
4.  **仔细检查脚本顶部的三个变量：`YOUR_MAC_LAN_IP`, `LOCAL_REGISTRY_PORT`, `K8S_YAML_ROOT_DIR`。** 尤其是 `K8S_YAML_ROOT_DIR`，再次确认它能覆盖您所有想修改的 K8s YAML 文件。
5.  **赋予执行权限：**
    ```bash
    chmod +x k8s_image_modifier.py
    ```
6.  **运行脚本启用代理：**
    ```bash
    sudo ./k8s_image_modifier.py enable
    ```

这次，您应该能看到 `busybox:1.36` 被正确识别并修改了，并且 `mac_docker_push_commands.sh` 文件中会包含相应的 `docker pull` 和 `docker push` 命令。
